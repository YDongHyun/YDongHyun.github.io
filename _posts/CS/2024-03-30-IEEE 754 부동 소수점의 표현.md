---
title:  " IEEE 754 부동 소수점 표현" 
excerpt: ""

categories:
  - CS

toc: true
toc_sticky: true
use_math: true

date: 2024-03-30
last_modified_at: 2024-03-30
header: 
  teaser: "assets/images/teaser/cs.png"

---


IEEE 754 위키를 참고하며 작성하였습니다. 더 자세한 내용은 위키를 참고해주세요

[IEEE 754](https://ko.wikipedia.org/wiki/IEEE_754)

C언어를 공부하다 부동 소수점 표현법에 대해 의문이 생겨 IEEE 754에 대해 공부하고 정리한 글입니다.

# IEEE 754 부동 소수점 표현

소수점은 정수부 이외에도 소수부를 표현 해야하기 때문에 일반적인 정수형의 표현법으로 표현하는데 한계가 있습니다.

이에 IEEE 754 표준을 통해 부동 소수점 표현을 표준화 하여 사용할 수 있게 하였습니다.

이 표준에서는 32비트 단정밀도 (single-precision) ,64비트 배정밀도(double-percision)에 대한 형식 등을 정의하고 있습니다. (이 외에도 여러 형식이 있습니다.) 

C로 예를 들면 float 형은 단정밀도, double 형은 배정밀도로 보면 됩니다.

부동소수점이 어떻게 표현되는 천천히 알아봅시다.

## 부동 소수점의 표기 방법

부동 소수점 표기를 위해 세 부분으로 나뉩니다.

![Untitled](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/c29a3c21-43c0-477f-b6f1-9f66ff2dff6b)


### 최상위 비트(MSB) : 부호 표시 (0,1)

최상위 비트 (MSB)는 부호 표시를 위해 양수는 0, 음수는 1로 대응됩니다.

### 지수부 (exponent)

32비트의 경우 8비트로 표현되며, bias를 더해 표현합니다.

### 가수부 (fraction)

32비트의 경우 23비트로 표현됩니다. 

가수 부분의 첫 번째 비트가 항상 1이라고 가정하고 나머지 비트들을 소수점 이하 자릿수로 취급하여 저장합니다.

양수, 음수의 부동 소수점 예시를 통해 쉽게 알아봅시다.

## 양수

32비트에서 123.625 의 10진수를 예시로 들어봅시다. 

### 부호 비트

123.625는 양수이기 때문에 최상위 비트는 0이 됩니다.

![Untitled 1](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/107cfadc-bb1f-44d9-aeb4-24afe7b372b2)

### 지수부

123.625 의 10진수를 예시로 들어봅시다. 먼저 10진수를 2진수로 변환합니다.

이후 소수점을 왼쪽으로 이동 시켜 정수부를 1로 만들어줍니다.

```
1111011.101 -> 1.111011101
```

왼쪽으로 총 6번 움직여  1.111011101으로 만들었고, 지수는 6이 됩니다.

이를 `정규화된 부동 소수점 수`이라 합니다.

이제 먼저 지수부의 비트를 구해봅시다.

IEE 754에서는 위에서 구한 지수 `6` 에 bias를 더해줍니다. 32비트의 경우 bias는 `127`입니다. 

따라서 지수부는 `127+6 = 133` 이 됩니다. 

구한 지수부를 2진수로 다시 바꾸어주면 지수부의 비트가 됩니다.

```
지수부의 2진수 비트
133 -> 10000101
```

그림으로 보면 다음과 같습니다.

![Untitled 2](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/f2e9c33c-a1f7-4395-990c-62d7ff0d6ff0)

bias 값을 더해주는 이유는 지수를 부호 없는 값으로 표현하기 위해서 입니다. 이렇게 함으로써 지수의 범위를 확장하여 작은 수와 큰 수를 모두 표현할 수 있게 됩니다. 하지만 그만큼 오차도 커집니다.

### 가수부

이제 가수부를 구해보겠습니다.

가수부는 전에 구한 `정규화된 부동 소수점 수` 에서 소수부입니다.

```
1.**111011101**    <- 색칠된 부분이 가수부
```

가수부는 총 23비트로 구성되어있기 때문에 남은 비트는 모두 0으로 채워줍니다.

최종으로 구한 가수부의 비트는 다음과 같습니다.

```
11101110100000000000000 <- 남은 부분을 0으로 채움
```

그림으로 보면 다음과 같습니다.

![Untitled 3](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/4b32ea1c-2a00-4064-883a-3178a82aaef8)

### 최종 결과

최종적으로 123.625는 다음과 같이 표현 됩니다.

```
123.625  =  01000010111101110100000000000000 
```

![Untitled 4](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/8e72fdd9-9433-4780-9153-5f396c0d9f71)

실제 메모리를 살펴보며 검증해보겠습니다.

![Untitled](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/192f34e5-0e04-40c1-ad15-5d1a299b18ce)

float형은 4byte이므로 `0x42F74000`의 값이 저장되어있습니다. (리틀 엔디안 이므로 거꾸로 읽습니다.)

이 값을 2진수로 변환하면 계산한 값과 같은 값이 됨을 볼 수 있습니다.

## 음수

음수의 경우도 간단합니다.

-123.625 음수의 경우 절댓값의 2진수를 구한 후 MSB를 1로 표현 해주면 됩니다.

즉 최종적으로는 123.625와 부호 비트만 다릅니다.

```
-123.625  =  11000010111101110100000000000000
```

![Untitled 5](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/368ae560-69c8-42c1-b901-fdd38dfc4f5e)

실제 메모리를 살펴보며 검증해보겠습니다.

![Untitled (1)](https://github.com/YDongHyun/YDongHyun.github.io/assets/80799025/7cc279a9-e77a-4213-9057-743c1e958774)

float형은 4byte이므로 `0xC2F74000`의 값이 저장되어있습니다. 

이 값 또한 2진수로 변환하면 계산한 값과 같은 값이 됨을 볼 수 있습니다.

# 마무리

IEEE 754 부동 소수점 표기 표준을 공부하면서 왜 float 형이 int형보다 범위가 넓은지, 또 왜 오차가 나는지에 대해 조금만 더 생각하면 자연스럽게 알게 될 것입니다.

관련 공부를 하시는 분들에게 도움이 됬으면 좋겠습니다.
